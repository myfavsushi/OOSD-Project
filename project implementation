from abc import ABC, abstractmethod
from datetime import datetime
from typing import List

# ==========================================
# 1. CLASS: USER
# ==========================================
class User(ABC):
    def __init__(self, userID, name, email, password, role):
        # Attributes strictly from Diagram 
        self.userID = userID
        self.name = name
        self.email = email
        self.__password = password  # Private attribute
        self.role = role
        
        # Relationships (0..* Association)
        self.reminders: List['Reminder'] = [] 
        self.feedbacks: List['Feedback'] = []

    # Methods strictly from Diagram 
    def login(self, input_password) -> bool:
        if input_password == self.__password:
            print(f"[System] Login successful for {self.name} ({self.role})")
            return True
        print("[System] Login failed.")
        return False

    def logout(self):
        print(f"[System] User {self.name} has logged out.")

    def updateProfile(self):
        print(f"[System] Profile updated for User: {self.name}")

    # --- RUBRIC REQUIREMENT: POLYMORPHISM ---
    # This abstract method forces 'Student', 'Lecturer', and 'TeamLeader' to 
    # implement their own version, satisfying the "2+ overridden methods" rubric requirement.
    @abstractmethod
    def dashboard(self):
        pass

# ==========================================
# 2. CLASS: STUDENT
# ==========================================
class Student(User):
    def __init__(self, userID, name, email, password, course, semester):
        super().__init__(userID, name, email, password, "Student")
        self.studentID = userID # Mapping userID to studentID
        self.course = course
        self.semester = semester

    # Methods strictly from Diagram 
    def joinTeam(self, teamID: str):
        print(f"[Student] Joining Team ID: {teamID}")

    def updateTask(self):
        print(f"[Student] Task updated.")

    def communicate(self, message: str):
        print(f"[Student] Sent message: {message}")

    def submitEvaluation(self):
        print(f"[Student] Evaluation submitted.")

    def viewTeamInfo(self):
        print(f"[Student] Viewing Team Info...")

    # Overridden method for Polymorphism (Rubric)
    def dashboard(self):
        print(f"\n--- STUDENT DASHBOARD ({self.name}) ---")
        print("1. View Team Info")
        print("2. Update Task")
        print("3. Communicate")

# ==========================================
# 3. CLASS: TEAM LEADER (Inherits from Student)
# ==========================================
class TeamLeader(Student):
    def __init__(self, userID, name, email, password, course, semester, appointedDate):
        super().__init__(userID, name, email, password, course, semester)
        self.leaderID = userID
        self.appointedDate = appointedDate
        self.contributionScore = 0.0

    # Methods strictly from Diagram 
    def assignTask(self):
        print(f"[Team Leader] Task assigned to member.")

    def monitorProgress(self):
        print(f"[Team Leader] Monitoring team progress...")

    def sendAnnouncement(self):
        print(f"[Team Leader] Announcement sent to team.")

    def approveDraft(self):
        print(f"[Team Leader] Draft approved.")

    # Overridden method for Polymorphism (Rubric)
    def dashboard(self):
        print(f"\n--- TEAM LEADER DASHBOARD ({self.name}) ---")
        print("1. Assign Task")
        print("2. Monitor Progress")
        print("3. Approve Draft")

# ==========================================
# 4. CLASS: LECTURER
# ==========================================
class Lecturer(User):
    def __init__(self, userID, name, email, password, department, faculty):
        super().__init__(userID, name, email, password, "Lecturer")
        self.lecturerID = userID
        self.department = department
        self.faculty = faculty

    # Methods strictly from Diagram 
    def createTeam(self):
        print(f"[Lecturer] New team created.")

    def viewAllTeam(self): # Note: Diagram says 'viewAllTeam' (singular)
        print(f"[Lecturer] Displaying all teams...")
        return []

    def reviewEvaluations(self):
        print(f"[Lecturer] Reviewing evaluations...")

    def approveResult(self):
        print(f"[Lecturer] Results approved.")

    # Overridden method for Polymorphism (Rubric)
    def dashboard(self):
        print(f"\n--- LECTURER DASHBOARD ({self.name}) ---")
        print("1. Create Team")
        print("2. View All Teams")
        print("3. Approve Results")

# ==========================================
# 5. CLASS: REMINDER
# ==========================================
class Reminder:
    def __init__(self, reminderID, message, dueDateTime, type_str):
        self.reminderID = reminderID
        self.message = message
        self.dueDateTime = dueDateTime
        self.isRead = False
        self.type = type_str

    # Methods strictly from Diagram 
    # Note: 'reminder(...)' in diagram implies the constructor, handled by __init__
    
    def sendNotification(self):
        print(f"[Notification] {self.message}")

    # Rubric Requirement: Overloaded Methods (Simulated)
    # Python simulates overloading using default arguments.
    def snooze(self, minutes: int = None):
        if minutes:
            print(f"[Reminder] Snoozed for {minutes} minutes.")
        else:
            print(f"[Reminder] Snoozed for default duration.")

    def getDetails(self) -> str:
        return f"{self.message} (Due: {self.dueDateTime})"

# ==========================================
# 6. CLASS: FEEDBACK
# ==========================================
class Feedback:
    def __init__(self, feedbackID, rating, comments, anonymous):
        self.feedbackID = feedbackID
        self.rating = rating
        self.comments = comments
        self.anonymous = anonymous

    def storeEvaluation(self) -> bool:
        print(f"[System] Feedback stored. Rating: {self.rating}")
        return True

# ==========================================
# 7. CLASS: PROGRESS & TASK & TEAM (Core Logic)
# ==========================================
class Progress:
    def __init__(self, comments, completionRate):
        self.lastUpdated = datetime.now()
        self.comments = comments
        self.completionRate = completionRate

    def calculateProgress(self) -> int:
        return int(self.completionRate)

    def showReport(self):
        print(f"Progress Report: {self.completionRate}% - {self.comments}")

    def addComment(self, msg: str):
        self.comments = msg
        print(f"Progress comment updated: {msg}")

class Task:
    def __init__(self, taskID, title):
        self.taskID = taskID
        self.title = title
        self.progress = 0
        self.status = "Pending"
        # Composition: Task has 1 Progress object
        self.progressDetails = Progress("", 0.0) 

    # Methods strictly from Diagram 
    def updateProgress(self, percent: int):
        self.progress = percent
        print(f"[Task] Progress updated to {percent}%")

    def getDetails(self) -> str:
        return f"Task: {self.title} [{self.status}]"

    def assignStudent(self, studentID: str):
        print(f"[Task] Assigned to student {studentID}")

class Team:
    def __init__(self, teamID, teamName, projectTitle, joinCode):
        self.teamID = teamID
        self.teamName = teamName
        self.projectTitle = projectTitle
        self.joinCode = joinCode
        # Aggregation: List of Student objects
        self.members: List[Student] = [] 
        # Composition: List of Task objects
        self.tasks: List[Task] = []      

    # Methods strictly from Diagram 
    def addMember(self, student: Student) -> bool:
        self.members.append(student)
        print(f"[Team] {student.name} added to {self.teamName}")
        return True

    def removeMember(self, studentID: str) -> bool:
        print(f"[Team] Member {studentID} removed.")
        return True

    def addTask(self, newTask: Task):
        self.tasks.append(newTask)
        print(f"[Team] Task '{newTask.title}' added.")

    def getProgress(self) -> float:
        print("[Team] Calculating team progress...")
        return 0.0

    def validateJoinCode(self, inputCode: str) -> bool:
        return self.joinCode == inputCode

# ==========================================
# 8. MAIN DRIVER (Task 6 - UI Implementation)
# ==========================================
def main():
    # Instantiate Objects (Task 5 Requirement)
    student1 = Student("S100", "Adriana", "adriana@uni.my", "123", "CS", 1)
    leader1 = TeamLeader("L200", "Mayar", "mayar@uni.my", "123", "CS", 1, "2025-01-01")
    lecturer1 = Lecturer("T500", "Dr Tan", "tan@uni.my", "admin", "SE", "FCSIT")

    # Put them in a list to simulate a database
    users = [student1, leader1, lecturer1]

    print("=========================================")
    print("      EZCOMM SYSTEM (STRICT BUILD)       ")
    print("=========================================")

    while True:
        print("\n--- LOGIN ---")
        email = input("Email (e.g., adriana@uni.my / admin): ")
        password = input("Password (e.g., 123 / admin): ")

        current_user = None
        for u in users:
            if u.email == email and u.login(password):
                current_user = u
                break
        
        if current_user:
            # Show Dashboard (Polymorphism)
            current_user.dashboard()

            # Simulate Interactions based on Role
            choice = input("\nSelect Option (1-3) or '0' to Logout: ")
            
            if choice == '0':
                current_user.logout()
                continue

            if isinstance(current_user, TeamLeader):
                if choice == '1': current_user.assignTask()
                elif choice == '2': current_user.monitorProgress()
                elif choice == '3': current_user.approveDraft()
            
            elif isinstance(current_user, Student): # This catches Leaders too, so check Leader first
                if choice == '1': current_user.viewTeamInfo()
                elif choice == '2': current_user.updateTask()
                elif choice == '3': 
                    msg = input("Enter message: ")
                    current_user.communicate(msg)
            
            elif isinstance(current_user, Lecturer):
                if choice == '1': current_user.createTeam()
                elif choice == '2': current_user.viewAllTeam()
                elif choice == '3': current_user.approveResult()
        else:
            print("Invalid credentials. Please try again.")

if __name__ == "__main__":
    main()
